{"version":3,"sources":["MatrixFun.js","Matrixtable.js","MatrixVisualization.js","App.js","reportWebVitals.js","index.js"],"names":["MatrixFun","matrix","this","paddingValue","index","squareLength","undefined","console","error","col","row","Array","keys","map","element","size","getIndex","range","maxDiagonal","winners","forEach","_","ind","candidates","localMax","el","counter","adjacentIndex","cInd","push","reduce","acc","columns","columWiseProduct","length","product","calculateProduct","numbers","MatrixTable","props","createTable","thisState","local","toBeMarked","mark","toBeSpeciallyMarked","markSpecial","cData","data","select","node","append","selectAll","enter","d","i","j","k","set","text","attr","get","needle","color","findIndex","class","ref","viewBox","preserveAspectRatio","className","Component","MatrixVisualization","antiDiagonalResult","columnlength","mfun","createContentForAntidiagonal","antiDiagonalIndex","getAntiDiagonalIndex","activeItem","Segment","textAlign","toString","CalculateProductForRange","diagonalResult","createContentForDiagonal","diagonalIndexes","getDiagonalIndex","rowResult","App","handleItemClick","e","name","setState","lines","replace","split","str","Number","parseInt","flattened","flat","diagonal","calculateDiagonal","content","getDiagonalContent","diagonalContent","diagonalExplanation","antiDiagonal","calculateAntidiagonal","antiDiagonalContent","getAntiDiagonalContent","antiDiagonalExplanation","calculateRows","rowContent","getRowContent","columnResult","calculateColumnwise","colContent","maxResult","ac","maxContent","Container","Card","Image","src","wrapped","ui","Content","Header","Meta","Description","extra","state","summaryContent","colInd","colLength","rowIndex","getRowIndexes","offset","debug","menues","scrollIntoView","explanation","Grid","divided","Column","Menu","attached","tabular","Item","active","onClick","React","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"kNAGaA,G,YAAb,WAEI,WAAYC,GAAS,oBACjBC,KAAKD,OAASA,EAGdC,KAAKC,aAAa,EAN1B,oDAiBI,SAAiBC,EAAOC,GAEpB,YADcC,IAAVF,QAAwCE,IAAjBD,GAA8BE,QAAQC,MAAM,0CAA2C,CAACJ,EAAOC,IAClHD,EAAQC,EAAgBD,IAnBxC,kCAsBI,SAAqBA,EAAOC,GAExB,YADcC,IAAVF,QAAwCE,IAAjBD,GAA8BE,QAAQC,MAAM,0CAA2C,CAACJ,EAAOC,IACjHA,EAAeD,EAAQ,EAAKC,EAAeD,IAxB5D,2BAkCI,SAAcK,EAAKC,GACf,OAAO,YAAIC,MAAMF,GAAKG,QAAQC,KAAI,SAAAC,GAAO,OAAIA,EAAUJ,OAnC/D,8BAuCI,SAAiBK,GACb,OAAO,YAAIJ,MAAMI,GAAMH,UAxC/B,sCA2CI,SAAyBP,EAAcW,EAAUC,GAAQ,IAAD,OAChDC,EAAc,EACdC,EAAU,GAyBd,OAtBA,YAAI,IAAIR,MAAMN,IAAee,SAAQ,SAACC,EAAGC,GAErC,IAAIC,EAAa,GACbC,EAAW,YAAI,IAAIb,MAAMM,IAAQJ,KAAI,SAACY,EAAIC,GAC1C,IAAIC,EAAcL,EAAMI,EAGxB,GAAIC,GAAetB,EAAgB,OAAO,EAAKF,aAE/C,IAAIyB,EAAOZ,EAASW,EAAetB,GAEnC,OADAkB,EAAWM,KAAKD,GACT,EAAK3B,OAAO2B,MAGlBE,QAAO,SAACC,EAAKN,GAAN,OAAaM,EAAMN,KAE3BD,EAAWN,IACXA,EAAcM,EACdL,EAAUI,MAIX,CAACL,EAAaC,KAtE7B,wCAkFI,SAA2BlB,EAAQgB,GAAQ,IAAD,OAElCe,EAAU,GACVC,EAAmB,GASvB,OARAhC,EAAOmB,SAAQ,SAAAN,GAEX,GADAkB,EAAQH,KAAKf,GACTkB,EAAQE,SAAWjB,EAAO,CAC1B,IAAMkB,EAAU,EAAKC,iBAAiBJ,GACtCA,EAAU,GACVC,EAAiBJ,KAAKM,OAGvBF,IA9Ff,8BAkGI,SAAiBI,GACb,OAAOA,EAAQP,QAAO,SAACC,EAAKjB,GAAN,OAAkBiB,EAAMjB,SAnGtD,M,yBC6EewB,E,kDAxEX,WAAYC,GAAQ,uCACVA,G,qDAGV,WAEIrC,KAAKsC,gB,gCAGT,WACItC,KAAKsC,gB,yBAIT,WACI,IAAIC,EAAYC,cACZC,EAAazC,KAAKqC,MAAMK,KACxBC,EAAsB3C,KAAKqC,MAAMO,YACjCC,EAAQ7C,KAAKqC,MAAMS,KAEbC,YAAO/C,KAAKgD,MAClBC,OAAO,KACNC,UAAU,KACVJ,KAAKD,GACLM,QACAF,OAAO,KACPC,UAAU,QACVJ,MAAK,SAAUM,EAAGC,EAAGC,EAAGC,GAA6B,OAAxBhB,EAAUiB,IAAIxD,KAAMqD,GAAWD,KAC5DD,QACAF,OAAO,QACPQ,MAAK,SAAUL,EAAGC,EAAGC,GAAK,OAAOF,KACjCM,KAAK,KAAK,SAAUN,EAAGC,GAAK,OAAY,GAAJA,EAAU,MAC9CK,KAAK,KAAK,SAAUN,EAAGC,GAAK,OAA8B,GAAtBd,EAAUoB,IAAI3D,MAAc,MAEhE0D,KAAK,cAAe,aACpBA,KAAK,YAAa,QAClBA,KAAK,QAAQ,SAAUN,EAAGC,GACvB,IAAIO,EAA+B,GAAtBrB,EAAUoB,IAAI3D,MAAaqD,EACpCQ,EAAQ,QAeZ,OAdIpB,IAGIoB,GADiD,IAAjDpB,EAAWqB,WAAU,SAACvC,GAAD,OAAQA,IAAOqC,KAC5B,SAEA,SAGZjB,IAC8D,IAA1DA,EAAoBmB,WAAU,SAACvC,GAAD,OAAQA,IAAOqC,OAC7CC,EAAQ,OAITA,O,oBAQnB,WAAU,IAAD,OAEL,OAAS,qBAAKE,MAAM,gBAAX,SACE,qBAAKC,IAAK,SAAAhB,GAAI,OAAI,EAAKA,KAAOA,GAAMiB,QAAQ,gBAAgBC,oBAAoB,gBAAgBC,UAAU,sB,GAlEnGC,a,SCgDXC,E,iLAtCX,SAA8BC,EAAoBC,EAAcxE,EAAQyE,EAAMC,GAG1E,IAAIC,EAAoB,YAAI,IAAIjE,MAAM,KAAKE,KAAI,SAACY,EAAIH,GAAU,OAAOoD,EAAKG,qBAAqBvD,EAAKmD,MAUpG,MAAO,CATmB,cAAC,EAAD,CAAazB,KAAM/C,EAAQ2C,KAAMgC,EAAmB9B,YAAa0B,EAAmB,IAAStE,KAAK4E,YAC9F,eAACC,EAAA,EAAD,CAASC,UAAU,OAAnB,UAC1B,cAACD,EAAA,EAAD,iJAD0B,qDAGI,8BAAMJ,EAA6BM,aAHvC,4DAKI,8BAAMP,EAAKQ,yBAAyBD,aALxC,4CAOI,8BAAMP,EAAKG,qBAAqBI,aAPpC,U,gCAWlC,SAA0BE,EAAgBV,EAAcxE,EAAQyE,EAAMU,GAElE,IAAIC,EAAkB,YAAI,IAAI1E,MAAM,KAAKE,KAAI,SAACY,EAAIH,GAAU,OAAOoD,EAAKY,iBAAiBhE,EAAKmD,MAU9F,MAAO,CATe,cAAC,EAAD,CAAazB,KAAM/C,EAAQ2C,KAAMyC,EAAiBvC,YAAaqC,EAAe,IAASjF,KAAK4E,YACxF,eAACC,EAAA,EAAD,CAASC,UAAU,OAAnB,UACtB,cAACD,EAAA,EAAD,4KADsB,iDAGF,8BAAMK,EAAyBH,aAH7B,4DAKF,8BAAMP,EAAKQ,yBAAyBD,aALlC,oBAMe,8BAAMP,EAAKY,iBAAiBL,mB,2BAKzE,SAAqBM,EAAWtF,GAAQ,IAAD,OACpC,OAAQsF,EAAU1E,KAAI,SAACY,EAAGH,GAAJ,OAAU,gCAAK,6CAAgBA,KAAS,cAAC,EAAD,CAAuB0B,KAAM/C,EAAS6C,YAAarB,EAAG,IAAS,EAAKqD,sB,GAjCvGR,a,6CCqOnBkB,E,kDAnOb,WAAYjD,GAAQ,IAAD,uBACjB,cAAMA,IA8HRkD,gBAAkB,SAACC,EAAD,GAAkB,IAAZC,EAAW,EAAXA,KACtB,EAAKC,SAAS,CAAEd,WAAYa,KA9H5B,IAqBIE,EArBO,qsCAqBMC,QAAQ,IAAK,IAAIC,MAAM,MAElC9F,EAAS,GACf4F,EAAMzE,SAAQ,SAACN,EAASV,GAAYH,EAAOG,GAASU,EAAQiF,MAAM,KAAKlF,KAAI,SAAAmF,GAAG,OAAIC,OAAOC,SAASF,SAElG,IAAMvB,EAAexE,EAAO,GAAGiC,OAEzBiE,EAAYlG,EAAOmG,OAEnB1B,EAAO,IAAI1E,EAAUmG,GAEvBE,EAAW,EAAKC,kBAAkB7B,EAAcC,GAEhD6B,EAAUhC,EAAoBiC,mBAAmBH,EAAU5B,EAAcxE,EAAQyE,EAAM,EAAK4B,mBAC1FG,EAAkBF,EAAQ,GAC1BG,EAAsBH,EAAQ,GAG9BI,EAAe,EAAKC,sBAAsBnC,EAAcC,GAGxDmC,GADNN,EAAUhC,EAAoBuC,uBAAuBH,EAAclC,EAAcxE,EAAQyE,EAAM,EAAKkC,wBAChE,GAC9BG,EAA0BR,EAAQ,GAEpChB,EAAY,EAAKyB,cAAcvC,EAAcC,GAC7CuC,EAAa1C,EAAoB2C,cAAc3B,EAAWtF,GAE1DkH,EAAe,EAAKC,oBAAoB3C,EAAcC,GACtD2C,EAAa9C,EAAoB2C,cAAcC,EAAclH,GAE5DqH,EAAY,sBAAI/B,EAAU1E,KAAI,SAAAY,GAAE,OAAEA,EAAG,OAAzB,YAAiC0F,EAAatG,KAAI,SAAAY,GAAE,OAAEA,EAAG,OAAzD,CAA8D4E,EAAS,GAAIM,EAAa,KAAI7E,QAAO,SAACyF,EAAI9F,GAAL,OAAU8F,EAAG9F,EAAGA,EAAG8F,KAGnIC,EAAY,eAACC,EAAA,EAAD,CAAWzC,UAAU,SAArB,cAA+B,eAAC0C,EAAA,EAAD,WAC/C,cAACC,EAAA,EAAD,CAAOC,IAAI,qHAAqHC,SAAO,EAACC,IAAI,IAC5I,eAACJ,EAAA,EAAKK,QAAN,WACE,cAACL,EAAA,EAAKM,OAAN,0BACA,cAACN,EAAA,EAAKO,KAAN,UACE,sBAAM5D,UAAU,OAAhB,sEAEF,cAACqD,EAAA,EAAKQ,YAAN,UACIZ,OAGN,cAACI,EAAA,EAAKK,QAAN,CAAcI,OAAK,UAnEF,OAwEjB,EAAKC,MAAQ,CACXpF,KAAM/C,EACNwE,aAAcA,EACdK,WAAY,GACZ2B,gBAAiBA,EACjBC,oBAAqBA,EACrBG,oBAAqBA,EACrBE,wBAAyBA,EACzBE,WAAYA,EACZI,WAAYA,EACZF,aAAcA,EACdkB,eAAgBb,GAnFD,E,qDAwFnB,SAAkB/C,EAAcC,GAE9B,OADkBA,EAAKQ,yBAAyBT,GAAc,SAAC6D,EAAQC,GAAT,OAAuB7D,EAAKY,iBAAiBgD,EAAQC,KAAY,K,mCAMjI,SAAsB9D,EAAcC,GAElC,OADmBA,EAAKQ,yBAAyBT,GAAc,SAAC6D,EAAQC,GAAT,OAAuB7D,EAAKG,qBAAqByD,EAAQC,KAAY,K,2BAItI,SAAclI,EAAcqE,GAC1B,IAAI8D,EAAW9D,EAAK+D,cAAcpI,EAAcA,GAC1CkF,EAAY,GAIlB,OAHA,YAAI,IAAI5E,MAAMN,IAAee,SAAQ,SAACC,EAAGqH,GAAJ,OACnCnD,EAAU1D,KAAK6C,EAAKQ,yBAAyB7E,GAAc,SAACiI,EAAQC,GAAT,OAAwBC,EAASF,GAAUI,IAAS,OAE1GnD,I,iCAGT,SAAoBlF,EAAcqE,GAChC,IAAMa,EAAY,GAIlB,OAHA,YAAI,IAAI5E,MAAMN,IAAee,SAAQ,SAACC,EAAGqH,GAAJ,OACnCnD,EAAU1D,KAAK6C,EAAKQ,yBAAyB7E,GAAc,SAACiI,EAAQC,GAAT,OAAwBD,EAAUC,EAAUG,IAAU,OAE5GnD,I,+BAIT,WACEhF,QAAQoI,MAAM,aAAczI,KAAK0I,QACjC1I,KAAK0I,OAAOC,mB,gCAId,WACE3I,KAAK0I,OAAOC,eAAe,CAAE,SAAY,SAAU,MAAS,Y,oBAM9D,WAAU,IAAD,OACH/D,EAAa5E,KAAKkI,MAAMtD,WACxByB,EAAU,GACVuC,EAAc,GAClB,OAAQhE,GACN,IAAK,WACHyB,EAAUrG,KAAKkI,MAAM3B,gBACrBqC,EAAc5I,KAAKkI,MAAM1B,oBACzB,MACF,IAAK,eACHH,EAAUrG,KAAKkI,MAAMvB,oBACrBiC,EAAc5I,KAAKkI,MAAMrB,wBACzB,MACF,IAAK,OACHR,EAAUrG,KAAKkI,MAAMnB,WACrB,MACF,IAAK,aACHV,EAAUrG,KAAKkI,MAAMf,WACrB,MACF,IAAK,UACHd,EAAUrG,KAAKkI,MAAMC,eAGzB,OACE,sBAAKhE,UAAU,MAAf,UAEE,qBAAKA,UAAU,aAAf,SACE,+CAGF,sBAAKA,UAAU,WAAf,UAIE,eAAC0E,EAAA,EAAD,CAAM/G,QAAS,EAAGgH,SAAO,EAAzB,UACE,cAACD,EAAA,EAAKE,OAAN,UACG1C,IAGH,cAACwC,EAAA,EAAKE,OAAN,UAEGH,OAKL,qBAAK5E,IAAK,SAAAzC,GAAE,OAAI,EAAKmH,OAASnH,GAA9B,SACE,eAACyH,EAAA,EAAD,CAAMC,SAAS,SAASC,SAAO,EAA/B,UACE,cAACF,EAAA,EAAKG,KAAN,CACE1D,KAAK,WACL2D,OAAuB,aAAfxE,EACRyE,QAASrJ,KAAKuF,gBAHhB,sBASA,cAACyD,EAAA,EAAKG,KAAN,CACE1D,KAAK,eACL2D,OAAuB,iBAAfxE,EACRyE,QAASrJ,KAAKuF,gBAHhB,0BAQA,cAACyD,EAAA,EAAKG,KAAN,CACE1D,KAAK,aACL2D,OAAuB,eAAfxE,EACRyE,QAASrJ,KAAKuF,gBAHhB,wBAQA,cAACyD,EAAA,EAAKG,KAAN,CACE1D,KAAK,OACL2D,OAAuB,SAAfxE,EACRyE,QAASrJ,KAAKuF,gBAHhB,kBAQA,cAACyD,EAAA,EAAKG,KAAN,CACE1D,KAAK,UACL2D,OAAuB,YAAfxE,EACRyE,QAASrJ,KAAKuF,gBAHhB,oC,GAtNI+D,IAAMlF,WCHTmF,EAZS,SAAAC,GAClBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCDdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,K","file":"static/js/main.6d597d63.chunk.js","sourcesContent":["/**\r\n * Contains Matrix functionality for finding max product of adjacent values in rows, columns, diagonal and antidiagonal.\r\n */\r\nexport class MatrixFun {\r\n\r\n    constructor(matrix) {\r\n        this.matrix = matrix;\r\n\r\n        //Padding the matrix with 1 for out of bounds values -( Alternative value would be 0)\r\n        this.paddingValue=1;\r\n\r\n        //Note: the functions toString only returns [native code] if you do NOT bind methods\r\n    }\r\n\r\n    /** 0-19\r\n     * Sum(j and i)\r\n     * @param {*} currentIndex \r\n     * @param {*} squareLength \r\n     * @returns \r\n     */\r\n    getDiagonalIndex(index, squareLength) {\r\n        if (index === undefined || squareLength === undefined) { console.error(\"Missing parameters:index, squarelength \", [index, squareLength]) }\r\n        return (index + squareLength * (index))\r\n    }\r\n\r\n    getAntiDiagonalIndex(index, squareLength) {\r\n        if (index === undefined || squareLength === undefined) { console.error(\"Missing parameters:index, squarelength \", [index, squareLength]) }\r\n        return ((squareLength - index - 1) + squareLength * index);\r\n    }\r\n    /**\r\n     * Creates row-wise indexes.\r\n     * (fany implementation, but not sure if it is particular fast or understandable)\r\n     * inspired by Matlab \r\n     * @param {int} col \r\n     * @param {int} row \r\n     * @returns \r\n     */\r\n    getRowIndexes(col, row) {\r\n        return [...Array(col).keys()].map(element => element * row);\r\n      \r\n    }\r\n\r\n    getColumnIndexes(size) {\r\n        return [...Array(size).keys()];\r\n    }\r\n\r\n    CalculateProductForRange(squareLength, getIndex, range) {\r\n        let maxDiagonal = 0;\r\n        let winners = [];\r\n\r\n        //Matlab inspired - stream from array instead of for(...)\r\n        [...new Array(squareLength)].forEach((_, ind) => {\r\n\r\n            let candidates = [];\r\n            let localMax = [...new Array(range)].map((el, counter) => {\r\n                let adjacentIndex=ind + counter;\r\n                \r\n                //Padding the matrix with 1 (0 is another alternative if you want to discard the last (range-1) values)\r\n                if (adjacentIndex>=squareLength) { return this.paddingValue }\r\n\r\n                let cInd = getIndex(adjacentIndex, squareLength);\r\n                candidates.push(cInd);\r\n                return this.matrix[cInd];\r\n            }\r\n            )\r\n                .reduce((acc, el) => acc * el);\r\n\r\n            if (localMax > maxDiagonal) {\r\n                maxDiagonal = localMax;\r\n                winners = candidates;\r\n            }\r\n        });\r\n\r\n        return [maxDiagonal, winners];\r\n    }\r\n    /**\r\n       * Calculates columnwise product for square matrix.\r\n       * Let the matrix by of the shape NxN, it will return\r\n       * a matrix in shape if (N/range)XN.\r\n       * For example, 20x20 will become 5x20.\r\n       * The matrix returned is flattened.\r\n       * @param {nXn matrix flattened} matrix \r\n       * @param {int} range \r\n       * @returns {(n/range)Xn matrix}\r\n       */\r\n    calculateColumnwiseProduct(matrix, range) {\r\n\r\n        let columns = [];\r\n        let columWiseProduct = [];\r\n        matrix.forEach(element => {\r\n            columns.push(element);\r\n            if (columns.length === range) {\r\n                const product = this.calculateProduct(columns);\r\n                columns = [];\r\n                columWiseProduct.push(product)\r\n            }\r\n        });\r\n        return columWiseProduct;\r\n    }\r\n\r\n\r\n    calculateProduct(numbers) {\r\n        return numbers.reduce((acc, element) => acc * element);\r\n    }\r\n\r\n}\r\n\r\n","\r\nimport React, { Component } from 'react';\r\nimport './App.css';\r\n\r\nimport { select, local } from 'd3-selection';\r\n\r\nclass MatrixTable extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n\r\n    componentDidMount() {\r\n\r\n        this.createTable();\r\n\r\n    }\r\n    componentDidUpdate() {\r\n        this.createTable();\r\n    }\r\n\r\n\r\n    createTable() {\r\n        let thisState = local();\r\n        let toBeMarked = this.props.mark;\r\n        let toBeSpeciallyMarked = this.props.markSpecial;\r\n        let cData = this.props.data;\r\n\r\n        let svg = select(this.node);\r\n        svg.append(\"g\")\r\n            .selectAll(\"g\")\r\n            .data(cData)\r\n            .enter()\r\n            .append(\"g\") //removing\r\n            .selectAll(\"text\") // these\r\n            .data(function (d, i, j, k) { thisState.set(this, i); return d }) //lines\r\n            .enter() //text displays normally\r\n            .append(\"text\")\r\n            .text(function (d, i, j) { return d; })\r\n            .attr(\"x\", function (d, i) { return (i * 40) + 20; })\r\n            .attr(\"y\", function (d, i) { return (thisState.get(this) * 40) + 90; })\r\n\r\n            .attr(\"font-family\", \"Helvetica\")\r\n            .attr(\"font-size\", \"20px\")\r\n            .attr(\"fill\", function (d, i) {\r\n                let needle = thisState.get(this) * 20 + i;\r\n                let color = \"black\"\r\n                if (toBeMarked) {\r\n\r\n                    if (toBeMarked.findIndex((el) => el === needle) !== -1) {\r\n                        color = \"Orange\";\r\n                    } else\r\n                        color = \"green\";\r\n                }\r\n\r\n                if (toBeSpeciallyMarked) {\r\n                    if (toBeSpeciallyMarked.findIndex((el) => el === needle) !== -1) {\r\n                        color = \"Red\";\r\n                    }\r\n                }\r\n\r\n                return color;\r\n\r\n            })\r\n\r\n\r\n    }\r\n\r\n\r\n    render() {\r\n\r\n        return ( <div class=\"svg-container\">\r\n                   <svg ref={node => this.node = node} viewBox=\"0 0 1000 1000\" preserveAspectRatio=\"xMidYMid meet\" className=\"svg-content\">\r\n                 </svg>\r\n                </div >\r\n        )\r\n    }\r\n\r\n}\r\n\r\nexport default MatrixTable;","/**\r\n *  Creates visualization components\r\n * \r\n */\r\nimport React, { Component } from 'react';\r\nimport './App.css';\r\nimport MatrixTable from './Matrixtable'\r\nimport {\r\n    Segment,\r\n    Grid\r\n} from 'semantic-ui-react';\r\nimport { MatrixFun } from './MatrixFun.js'\r\n\r\n\r\n\r\nclass MatrixVisualization extends Component {\r\n    static getAntiDiagonalContent(antiDiagonalResult, columnlength, matrix, mfun, createContentForAntidiagonal) {\r\n\r\n\r\n        let antiDiagonalIndex = [...new Array(20)].map((el, ind) => { return mfun.getAntiDiagonalIndex(ind, columnlength) });\r\n        let antiDiagonalContent = <MatrixTable data={matrix} mark={antiDiagonalIndex} markSpecial={antiDiagonalResult[1]} key={this.activeItem}></MatrixTable>;\r\n        let antiDiagonalExplanation = <Segment textAlign=\"left\">\r\n            <Segment>Hadde vært greit med en funksjon for å transponere identitetsmatrise, men det er heller ingen problem å beregne indeksene</Segment>\r\n                                          createContentForAntidiagonal initiating callstack:\r\n                                          <pre>{createContentForAntidiagonal.toString()}</pre>\r\n                                          CalculateProductForRange - Method used by both diagonals:\r\n                                          <pre>{mfun.CalculateProductForRange.toString()}</pre>\r\n                                          Calculate indexes - getAntiDiagonalIndex:\r\n                                          <pre>{mfun.getAntiDiagonalIndex.toString()}</pre> </Segment>\r\n        return [antiDiagonalContent, antiDiagonalExplanation]\r\n    }\r\n\r\n    static getDiagonalContent(diagonalResult, columnlength, matrix, mfun, createContentForDiagonal) {\r\n        //Creating view information for diagonals    \r\n        let diagonalIndexes = [...new Array(20)].map((el, ind) => { return mfun.getDiagonalIndex(ind, columnlength) });\r\n        let diagonalContent = <MatrixTable data={matrix} mark={diagonalIndexes} markSpecial={diagonalResult[1]} key={this.activeItem}></MatrixTable>;\r\n        let diagonalExplanation = <Segment textAlign=\"left\">\r\n            <Segment>Jeg hadde nok foretrukket en Matlab tilnærming her - altså lage en identitetsmatrise og gjort en matrise operasjon. Dette er dog en grei implementasjon</Segment>\r\n                                createContentForDiagonal initiating callstack:\r\n                                <pre>{createContentForDiagonal.toString()}</pre>\r\n                                CalculateProductForRange - Method used by both diagonals:\r\n                                <pre>{mfun.CalculateProductForRange.toString()}</pre>\r\n                                Calculate index: <pre>{mfun.getDiagonalIndex.toString()}</pre>\r\n        </Segment>\r\n        return [diagonalContent, diagonalExplanation]\r\n    }\r\n\r\n    static getRowContent(rowResult, matrix){\r\n       return  rowResult.map((el,ind)=><div><h3>Row number {ind}</h3><MatrixTable key={ind} data={matrix}  markSpecial={el[1]} key={this.activeItem}></MatrixTable></div>);\r\n\r\n    }\r\n\r\n}\r\n\r\nexport default MatrixVisualization","\nimport './App.css';\nimport 'semantic-ui-css/semantic.min.css'\nimport React from 'react';\nimport { MatrixFun } from './MatrixFun.js'\nimport MatrixTable from './Matrixtable.js';\nimport MatrixVisualization from './MatrixVisualization'\nimport {\n  Grid,\n  Menu,\n  Card,\n  Image,\n  Icon,\n  Container\n} from 'semantic-ui-react';\nclass App extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let text = \"08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\\n\" +\n      \"49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\\n\" +\n      \"81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\\n\" +\n      \"52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\\n\" +\n      \"22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\\n\" +\n      \"24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\\n\" +\n      \"32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\\n\" +\n      \"67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\\n\" +\n      \"24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\\n\" +\n      \"21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\\n\" +\n      \"78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\\n\" +\n      \"16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\\n\" +\n      \"86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\\n\" +\n      \"19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\\n\" +\n      \"04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\\n\" +\n      \"88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\\n\" +\n      \"04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\\n\" +\n      \"20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\\n\" +\n      \"20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\\n\" +\n      \"01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\";\n\n    let lines = text.replace('\"', \"\").split(\"\\n\");\n\n    const matrix = [];\n    lines.forEach((element, index) => { matrix[index] = element.split(\" \").map(str => Number.parseInt(str)) });\n\n    const columnlength = matrix[0].length;\n\n    const flattened = matrix.flat();\n\n    const mfun = new MatrixFun(flattened);\n    //Calculating diagional\n    let diagonal = this.calculateDiagonal(columnlength, mfun);\n    //creating view for Diagonal\n    let content = MatrixVisualization.getDiagonalContent(diagonal, columnlength, matrix, mfun, this.calculateDiagonal);\n    const diagonalContent = content[0];\n    const diagonalExplanation = content[1];\n\n    //Calculating antidiagonal\n    const antiDiagonal = this.calculateAntidiagonal(columnlength, mfun);\n    //Creating view for antidiagonals\n    content = MatrixVisualization.getAntiDiagonalContent(antiDiagonal, columnlength, matrix, mfun, this.calculateAntidiagonal);\n    const antiDiagonalContent = content[0];\n    const antiDiagonalExplanation = content[1];\n\n    let rowResult = this.calculateRows(columnlength, mfun);\n    let rowContent = MatrixVisualization.getRowContent(rowResult, matrix);\n\n    let columnResult = this.calculateColumnwise(columnlength, mfun);\n    let colContent = MatrixVisualization.getRowContent(columnResult, matrix);\n\n     let maxResult=  [...rowResult.map(el=>el[0]), ...columnResult.map(el=>el[0]), diagonal[0], antiDiagonal[0]].reduce((ac, el)=>ac<el?el:ac);\n    \n    \n    let maxContent =<Container textAlign=\"center\"> <Card>\n    <Image src='https://www.flaticon.com/svg/vstatic/svg/261/261992.svg?token=exp=1616746093~hmac=1da234452297d55dfca6fe21e1ccca32' wrapped ui={false} />\n    <Card.Content>\n      <Card.Header>Max of four</Card.Header>\n      <Card.Meta>\n        <span className='date'>diagonally, antiDiagonally, row-wise and columnwise...</span>\n      </Card.Meta>\n      <Card.Description>\n         {maxResult}\n      </Card.Description>\n    </Card.Content>\n    <Card.Content extra>\n        \n    </Card.Content>\n  </Card>\n  </Container>\n    this.state = {\n      data: matrix,\n      columnlength: columnlength,\n      activeItem: {},\n      diagonalContent: diagonalContent,\n      diagonalExplanation: diagonalExplanation,\n      antiDiagonalContent: antiDiagonalContent,\n      antiDiagonalExplanation: antiDiagonalExplanation,\n      rowContent: rowContent,\n      colContent: colContent,\n      columnResult: columnResult,\n      summaryContent: maxContent\n    };\n\n  }\n  //Althought these methods are short enough to be inlined it is a central part of the logic so it makes sense to seperate them and it could be advantageous for test.\n  calculateDiagonal(columnlength, mfun) {\n    let diagonalMax = mfun.CalculateProductForRange(columnlength, (colInd, colLength) => mfun.getDiagonalIndex(colInd, colLength), 4);\n    return diagonalMax;\n\n  }\n\n  //Althought these methods are short enough to be inlined it is a central part of the logic so it makes sense to seperate them and it could be advantageous for test.\n  calculateAntidiagonal(columnlength, mfun) {\n    let antiDiagonal = mfun.CalculateProductForRange(columnlength, (colInd, colLength) => mfun.getAntiDiagonalIndex(colInd, colLength), 4)\n    return antiDiagonal;\n  }\n\n  calculateRows(squareLength, mfun) {\n    let rowIndex = mfun.getRowIndexes(squareLength, squareLength);\n    const rowResult = [];\n    [...new Array(squareLength)].forEach((_, offset) =>\n      rowResult.push(mfun.CalculateProductForRange(squareLength, (colInd, colLength) => (rowIndex[colInd] + offset), 4))\n    )\n    return rowResult;\n  }\n\n  calculateColumnwise(squareLength, mfun) {\n    const rowResult = [];\n    [...new Array(squareLength)].forEach((_, offset) =>\n      rowResult.push(mfun.CalculateProductForRange(squareLength, (colInd, colLength) => (colInd + (colLength*offset)), 4))\n    )\n    return rowResult;\n  }\n\n  //React lifecycle method. Ignore\n  componentDidMount() {\n    console.debug(\"this.menus\", this.menues);\n    this.menues.scrollIntoView();\n\n  }\n  //React lifecycle method. Ignore\n  componentDidUpdate() {\n    this.menues.scrollIntoView({ \"behavior\": \"smooth\", \"block\": \"start\" });\n  }\n  handleItemClick = (e, { name }) => {\n    this.setState({ activeItem: name })\n  }\n\n  render() {\n    let activeItem = this.state.activeItem;\n    let content = \"\";\n    let explanation = \"\";\n    switch (activeItem) {\n      case \"Diagonal\":\n        content = this.state.diagonalContent;\n        explanation = this.state.diagonalExplanation;\n        break;\n      case \"AntiDiagonal\":\n        content = this.state.antiDiagonalContent\n        explanation = this.state.antiDiagonalExplanation\n        break;\n      case \"Rows\":\n        content = this.state.rowContent;\n        break;\n      case \"Columnwise\":\n        content = this.state.colContent;\n        break;\n      case \"Summary\":\n        content = this.state.summaryContent;\n        break;\n    }\n    return (\n      <div className=\"App\">\n\n        <div className=\"App-header\">\n          <h2>M A T R I X</h2>\n        </div>\n\n        <div className=\"App-body\">\n\n\n\n          <Grid columns={2} divided>\n            <Grid.Column>\n              {content}\n            </Grid.Column>\n\n            <Grid.Column>\n\n              {explanation}\n\n\n            </Grid.Column>\n          </Grid>\n          <div ref={el => this.menues = el}>\n            <Menu attached='bottom' tabular>\n              <Menu.Item\n                name='Diagonal'\n                active={activeItem === 'Diagonal'}\n                onClick={this.handleItemClick}\n\n              >\n                Diagonal\n                      </Menu.Item>\n\n              <Menu.Item\n                name='AntiDiagonal'\n                active={activeItem === 'AntiDiagonal'}\n                onClick={this.handleItemClick}\n              >\n                AntiDiagonal\n                      </Menu.Item>\n\n              <Menu.Item\n                name='Columnwise'\n                active={activeItem === 'Columnwise'}\n                onClick={this.handleItemClick}\n              >\n                Columnwise\n                      </Menu.Item>\n\n              <Menu.Item\n                name='Rows'\n                active={activeItem === 'Rows'}\n                onClick={this.handleItemClick}\n              >\n                Rows\n                      </Menu.Item>\n\n              <Menu.Item\n                name='Summary'\n                active={activeItem === 'Summary'}\n                onClick={this.handleItemClick}\n              >\n                Summary\n                      </Menu.Item>\n            </Menu>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}