{"version":3,"sources":["main/MatrixFun.js","main/Matrixtable.js","main/MatrixVisualization.js","App.js","reportWebVitals.js","index.js"],"names":["MatrixFun","matrix","this","paddingValue","index","squareLength","undefined","console","error","col","row","Array","keys","map","element","getIndex","range","maxDiagonal","winners","forEach","_","ind","candidates","localMax","el","counter","adjacentIndex","cInd","push","reduce","acc","numbers","MatrixTable","createTable","thisState","local","toBeMarked","props","mark","toBeSpeciallyMarked","markSpecial","cData","data","select","node","append","selectAll","enter","d","i","j","k","set","text","attr","get","needle","color","findIndex","className","ref","viewBox","preserveAspectRatio","Component","MatrixVisualization","antiDiagonalResult","columnlength","mfun","createContentForAntidiagonal","antiDiagonalIndex","getAntiDiagonalIndex","antiDiagonalContent","activeItem","callStack","getcallStackForAntiDiagonal","Segment","textAlign","href","commons","getCommonMethods","commonMethod","diagonalResult","createContentForDiagonal","diagonalIndexes","getDiagonalIndex","diagonalContent","getcallStackForDiagonal","rowResult","App","handleItemClick","e","name","setState","lines","replace","split","str","Number","parseInt","length","flattened","flat","diagonal","calculateDiagonal","content","getDiagonalContent","diagonalExplanation","antiDiagonal","calculateAntidiagonal","getAntiDiagonalContent","antiDiagonalExplanation","calculateRows","rowContent","getRowContent","columnResult","calculateColumnwise","colContent","maxResult","ac","maxContent","Container","Card","Image","src","wrapped","ui","Content","Header","Meta","Description","extra","state","summaryContent","CalculateProductForRange","colInd","colLength","rowIndex","getRowIndexes","offset","debug","menues","scrollIntoView","explanation","Grid","columns","divided","Column","Menu","attached","tabular","Item","active","onClick","React","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","log"],"mappings":"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","file":"static/js/main.c02d5add.chunk.js","sourcesContent":["/**\r\n * Contains Matrix functionality for finding max product of adjacent values in rows, columns, diagonal and antidiagonal.\r\n */\r\nexport class MatrixFun {\r\n\r\n    constructor(matrix) {\r\n        this.matrix = matrix;\r\n\r\n        //Padding the matrix with 1 for out of bounds values -( Alternative value would be 0)\r\n        this.paddingValue = 1;\r\n\r\n        //Note: the functions toString only returns [native code] if you do NOT bind methods\r\n    }\r\n\r\n    /** \r\n     * Calculates the position of a diagional value \r\n     * for a column\r\n     * @param {int} currentIndex \r\n     * @param {int} squareLength \r\n     * @returns  returns index + (squareLength*index )\r\n     */\r\n    getDiagonalIndex(index, squareLength) {\r\n        if (index === undefined || squareLength === undefined) { console.error(\"Missing parameters:index, squarelength \", [index, squareLength]) }\r\n        return (index + squareLength * index);\r\n    }\r\n    /**\r\n     * Calculates the position of an antidiagonal\r\n     * value for a column index.\r\n     * @param {int} index \r\n     * @param {int} squareLength \r\n     * @returns \r\n     */\r\n    getAntiDiagonalIndex(index, squareLength) {\r\n        if (index === undefined || squareLength === undefined) { console.error(\"Missing parameters:index, squarelength \", [index, squareLength]) }\r\n        return ((squareLength - index - 1) + squareLength * index);\r\n    }\r\n    /**\r\n     * Creates row-wise indexes.\r\n     * \r\n     * Parameters\r\n     *   col = Squarelength\r\n     *   row = squareLength\r\n     * \r\n     * @param {int} col \r\n     * @param {int} row \r\n     * @returns int [] of indexes in the first row\r\n     */\r\n    getRowIndexes(col, row) {\r\n        return [...Array(col).keys()].map(element => element * row);\r\n\r\n    }\r\n    /**\r\n     * This method does the actual calcuation of product between \"range\" values.\r\n     * The function passed as a parameter provides the index of values to be used,\r\n     * and is called 0...squarelength-1 times, with the counter as parameter. if the \r\n     * counter is increased beyond squarelength this method return the padding value,\r\n     * i.e. increasing the dimension of the matrix. The padding value is hard-coded to\r\n     * 1. \r\n     * @param {int} squareLength \r\n     * @param {func(currentIndex, squareLength) return index of value} getIndex \r\n     * @param {int} range \r\n     * @returns [int max, [...indexes]]\r\n     */\r\n    CalculateProductForRange(squareLength, getIndex, range) {\r\n        let maxDiagonal = 0;\r\n        let winners = [];\r\n\r\n        //Stream of indexes vs for-loop?\r\n        [...new Array(squareLength)].forEach((_, ind) => {\r\n\r\n            let candidates = [];\r\n            let localMax = [...new Array(range)].map((el, counter) => {\r\n                let adjacentIndex = ind + counter;\r\n\r\n                //Padding the matrix with 1 (0 is another alternative if you want to discard the last (range-1) values)\r\n                if (adjacentIndex >= squareLength) { return this.paddingValue }\r\n\r\n                let cInd = getIndex(adjacentIndex, squareLength);\r\n                candidates.push(cInd);\r\n                return this.matrix[cInd];\r\n            }\r\n            )\r\n                .reduce((acc, el) => acc * el);\r\n\r\n            if (localMax > maxDiagonal) {\r\n                maxDiagonal = localMax;\r\n                winners = candidates;\r\n            }\r\n        });\r\n\r\n        return [maxDiagonal, winners];\r\n    }\r\n\r\n    /**\r\n     * Multiplication of array of numbers.\r\n     * @param {Number} numbers \r\n     * @returns \r\n     */\r\n    calculateProduct(numbers) {\r\n        return numbers.reduce((acc, element) => acc * element);\r\n    }\r\n\r\n}\r\n\r\n","\r\nimport React, { Component } from 'react';\r\n\r\n\r\nimport { select, local } from 'd3-selection';\r\n\r\nclass MatrixTable extends Component {\r\n \r\n    componentDidMount() {\r\n\r\n        this.createTable();\r\n\r\n    }\r\n    componentDidUpdate() {\r\n        this.createTable();\r\n    }\r\n\r\n\r\n    createTable() {\r\n        let thisState = local();\r\n        let toBeMarked = this.props.mark;\r\n        let toBeSpeciallyMarked = this.props.markSpecial;\r\n        let cData = this.props.data;\r\n\r\n        let svg = select(this.node);\r\n        svg.append(\"g\")\r\n            .selectAll(\"g\")\r\n            .data(cData)\r\n            .enter()\r\n            .append(\"g\") //removing\r\n            .selectAll(\"text\") // these\r\n            .data(function (d, i, j, k) { thisState.set(this, i); return d }) //lines\r\n            .enter() //text displays normally\r\n            .append(\"text\")\r\n            .text(function (d, i, j) { return d; })\r\n            .attr(\"x\", function (d, i) { return (i * 40) + 20; })\r\n            .attr(\"y\", function (d, i) { return (thisState.get(this) * 40) + 90; })\r\n\r\n            .attr(\"font-family\", \"Helvetica\")\r\n            .attr(\"font-size\", \"20px\")\r\n            .attr(\"fill\", function (d, i) {\r\n                let needle = thisState.get(this) * 20 + i;\r\n                let color = \"black\"\r\n                if (toBeMarked) {\r\n\r\n                    if (toBeMarked.findIndex((el) => el === needle) !== -1) {\r\n                        color = \"Orange\";\r\n                    } else\r\n                        color = \"green\";\r\n                }\r\n\r\n                if (toBeSpeciallyMarked) {\r\n                    if (toBeSpeciallyMarked.findIndex((el) => el === needle) !== -1) {\r\n                        color = \"Red\";\r\n                    }\r\n                }\r\n\r\n                return color;\r\n\r\n            })\r\n    }\r\n\r\n\r\n    render() {\r\n\r\n        return ( <div className=\"svg-container\">\r\n                   <svg ref={node => this.node = node} viewBox=\"0 0 1000 1000\" preserveAspectRatio=\"xMidYMid meet\" className=\"svg-content\">\r\n                 </svg>\r\n                </div >\r\n        )\r\n    }\r\n\r\n}\r\n\r\nexport default MatrixTable;","/**\r\n *  Creates visualization components\r\n * \r\n */\r\nimport React, { Component } from 'react';\r\nimport MatrixTable from './Matrixtable'\r\nimport {\r\n    Segment,\r\n\r\n} from 'semantic-ui-react';\r\n\r\n\r\n\r\n\r\nclass MatrixVisualization extends Component {\r\n    static getAntiDiagonalContent(antiDiagonalResult, columnlength, matrix, mfun, createContentForAntidiagonal) {\r\n\r\n\r\n        let antiDiagonalIndex = [...new Array(20)].map((el, ind) => { return mfun.getAntiDiagonalIndex(ind, columnlength) });\r\n        let antiDiagonalContent = <div><h3> Product:{antiDiagonalResult[0]}</h3><MatrixTable data={matrix} mark={antiDiagonalIndex} markSpecial={antiDiagonalResult[1]} key={this.activeItem}></MatrixTable></div>;\r\n        let callStack = this.getcallStackForAntiDiagonal();\r\n\r\n        let antiDiagonalExplanation = <Segment textAlign=\"left\">\r\n            <Segment>Alternative would be transposing the matrix</Segment>\r\n                     Initiating calculation from <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/App.js\" >App.js</a> with diagional index finder method.\r\n                                <pre>{callStack[0]}</pre>\r\n                                antidiagonal index finder method defined in <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>;\r\n                                <pre>{callStack[1]}</pre>\r\n                                This calculation method calls indexfinder and finds it's adjacent values defined in<a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.\r\n                                This method is used for all type of iterations:\r\n                                <pre>{callStack[2]}</pre>\r\n                                Seperated the actual Multiplication in a seperate method. I can imagine a situation where there will be need to change this operation. Defined in<a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.\r\n                                <pre>{callStack[3]}</pre>\r\n                </Segment>\r\n        return [antiDiagonalContent, antiDiagonalExplanation]\r\n    }\r\n\r\n\r\n\r\n    static getcallStackForAntiDiagonal() {\r\n        const methodInitiate = `\r\n    /**\r\n     * Method to initiate calculation of antidiagonal\r\n     * @param {int} columnlength \r\n     * @param {MatrixFun} mfun \r\n     * @returns [int max, [...indexes]]\r\n     */\r\n    calculateAntidiagonal(columnlength, mfun) {\r\n        let antiDiagonal = mfun.CalculateProductForRange(columnlength, \r\n            (colInd, colLength) => mfun.getAntiDiagonalIndex(colInd, colLength), 4)\r\n        return antiDiagonal;\r\n    }\r\n        `;\r\n\r\n        const methodIndexfinder =`\r\n    /**\r\n    * Calculates the position of an antidiagonal\r\n    * value for a column index.\r\n    * @param {int} index \r\n    * @param {int} squareLength \r\n    * @returns \r\n    */\r\n    getAntiDiagonalIndex(index, squareLength) {\r\n       if (index === undefined || squareLength === undefined) { \r\n           console.error(\"Missing parameters:index, squarelength \", [index, squareLength])\r\n        }\r\n       return ((squareLength - index - 1) + squareLength * index);\r\n    }\r\n    `;\r\n       let commons = this.getCommonMethods();\r\n        return [methodInitiate, methodIndexfinder, ...commons];\r\n    }\r\n\r\n    static getcallStackForDiagonal() {\r\n        const methodInitiate = `\r\n    /**\r\n    *  Method to initate the calculation\r\n    * Althought these methods are short enough to be inlined \r\n    * it is a central part of the logic so it makes \r\n    * sense to seperate them and it could be advantageous for test.\r\n    * @param {*} columnlength \r\n    * @param {*} mfun \r\n    * @returns [int max, [...indexes]]\r\n    */\r\n    calculateDiagonal(columnlength, mfun) {\r\n            let diagonalMax = mfun.CalculateProductForRange(columnlength, \r\n            (colInd, colLength) => mfun.getDiagonalIndex(colInd, colLength), 4);\r\n        return diagonalMax;\r\n    }`;\r\n\r\n    const methodIndexfinder = `\r\n    /** \r\n     * Calculates the position of a diagional value \r\n     * for a column\r\n     * @param {int} currentIndex \r\n     * @param {int} squareLength \r\n     * @returns  returns index + (squareLength*index )\r\n     */\r\n    getDiagonalIndex(index, squareLength) {\r\n        if (index === undefined || squareLength === undefined) { \r\n            console.error(\"Missing parameters:index, squarelength \", [index, squareLength]) \r\n        }\r\n        return (index + squareLength * index);\r\n    }\r\n    `;\r\n       const commonMethod = this.getCommonMethods();\r\n       return [methodInitiate, methodIndexfinder, ...commonMethod]\r\n    }\r\n    static getCommonMethods() {\r\n        const methodCalculator = `\r\n    /**\r\n     * This method does the actual calcuation of product between \"range\" values.\r\n     * The function passed as a parameter provides the index of values to be used,\r\n     * and is called 0...squarelength-1 times, with the counter as parameter. if the \r\n     * counter is increased beyond squarelength this method return the padding value,\r\n     * i.e. increasing the dimension of the matrix. The padding value is hard-coded to\r\n     * 1. \r\n     * @param {int} squareLength \r\n     * @param {func(currentIndex, squareLength) return index of value} getIndex \r\n     * @param {int} range \r\n     * @returns [int max, [...indexes]]\r\n     */\r\n    CalculateProductForRange(squareLength, getIndex, range) {\r\n        let maxDiagonal = 0;\r\n        let winners = [];\r\n\r\n        //Stream of indexes vs for-loop?\r\n        [...new Array(squareLength)].forEach((_, ind) => {\r\n\r\n            let candidates = [];\r\n            let localMax = [...new Array(range)].map((el, counter) => {\r\n                let adjacentIndex = ind + counter;\r\n\r\n                //Padding the matrix with 1 (0 is another \r\n                //alternative if you want to discard the last (range-1) values)\r\n                if (adjacentIndex >= squareLength) { return this.paddingValue }\r\n\r\n                let cInd = getIndex(adjacentIndex, squareLength);\r\n                candidates.push(cInd);\r\n                return this.matrix[cInd];\r\n            }\r\n            )\r\n                .reduce((acc, el) => acc * el);\r\n\r\n            if (localMax > maxDiagonal) {\r\n                maxDiagonal = localMax;\r\n                winners = candidates;\r\n            }\r\n        });\r\n\r\n        return [maxDiagonal, winners];\r\n        }\r\n       `;\r\n\r\n        const methodMulti = `\r\n       /**\r\n       * Multiplication of array of numbers.\r\n       * @param {Number} numbers \r\n       * @returns \r\n       */\r\n       calculateProduct(numbers) {\r\n        return numbers.reduce((acc, element) => acc * element);\r\n        }`\r\n\r\n\r\n        return [ methodCalculator, methodMulti];\r\n\r\n    }\r\n\r\n    static getDiagonalContent(diagonalResult, columnlength, matrix, mfun, createContentForDiagonal) {\r\n        //Creating view information for diagonals    \r\n        let diagonalIndexes = [...new Array(20)].map((el, ind) => { return mfun.getDiagonalIndex(ind, columnlength) });\r\n        let diagonalContent = <div><h3> Product:{diagonalResult[0]}</h3> <MatrixTable data={matrix} mark={diagonalIndexes} markSpecial={diagonalResult[1]} key={this.activeItem}></MatrixTable></div>;\r\n        let callStack = this.getcallStackForDiagonal();\r\n        \r\n\r\n        let diagonalExplanation = <Segment textAlign=\"left\">\r\n            <Segment>In Matlab it would have simply been creating identity matrix with equal dimensions and multiply</Segment>\r\n                                Initiating calculation from <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/App.js\" >App.js</a> with diagional index finder method.\r\n                                <pre>{callStack[0]}</pre>\r\n                                The Diagonal index finder method defined in <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>;\r\n                                <pre>{callStack[1]}</pre>\r\n                                This calculation method calls indexfinder and finds it's adjacent values defined in<a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.\r\n                                This method is used for type of iteration:\r\n                                <pre>{callStack[2]}</pre>\r\n                                Seperated the actual Multiplication in a seperate method. I can imagine a situation where there will be need to change this operation. Defined in<a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.\r\n                                <pre>{callStack[3]}</pre>\r\n\r\n        </Segment>\r\n        return [diagonalContent, diagonalExplanation]\r\n    }\r\n\r\n    static getRowContent(rowResult, matrix) {\r\n        return rowResult.map((el, ind) => <div><h3>Row number {ind}. Product:{el[0]}</h3><MatrixTable key={ind} data={matrix} markSpecial={el[1]} ></MatrixTable></div>);\r\n\r\n    }\r\n\r\n}\r\n\r\nexport default MatrixVisualization","\nimport './App.css';\nimport 'semantic-ui-css/semantic.min.css'\nimport React from 'react';\nimport { MatrixFun } from './main/MatrixFun.js'\n\nimport MatrixVisualization from './main/MatrixVisualization'\nimport {\n  Grid,\n  Menu,\n  Card,\n  Image,\n  Container\n} from 'semantic-ui-react';\nclass App extends React.Component {\n\n  constructor(props) {\n    super(props)\n    let text = \"08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\\n\" +\n      \"49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\\n\" +\n      \"81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\\n\" +\n      \"52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\\n\" +\n      \"22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\\n\" +\n      \"24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\\n\" +\n      \"32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\\n\" +\n      \"67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\\n\" +\n      \"24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\\n\" +\n      \"21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\\n\" +\n      \"78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\\n\" +\n      \"16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\\n\" +\n      \"86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\\n\" +\n      \"19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\\n\" +\n      \"04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\\n\" +\n      \"88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\\n\" +\n      \"04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\\n\" +\n      \"20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\\n\" +\n      \"20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\\n\" +\n      \"01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\";\n\n    let lines = text.replace('\"', \"\").split(\"\\n\");\n\n    const matrix = [];\n    lines.forEach((element, index) => { matrix[index] = element.split(\" \").map(str => Number.parseInt(str)) });\n\n    const columnlength = matrix[0].length;\n\n    const flattened = matrix.flat();\n\n    const mfun = new MatrixFun(flattened);\n    //Calculating diagional\n    let diagonal = this.calculateDiagonal(columnlength, mfun);\n    //creating view for Diagonal\n    let content = MatrixVisualization.getDiagonalContent(diagonal, columnlength, matrix, mfun, this.calculateDiagonal);\n    const diagonalContent = content[0];\n    const diagonalExplanation = content[1];\n\n    //Calculating antidiagonal\n    const antiDiagonal = this.calculateAntidiagonal(columnlength, mfun);\n    //Creating view for antidiagonals\n    content = MatrixVisualization.getAntiDiagonalContent(antiDiagonal, columnlength, matrix, mfun, this.calculateAntidiagonal);\n    const antiDiagonalContent = content[0];\n    const antiDiagonalExplanation = content[1];\n\n    let rowResult = this.calculateRows(columnlength, mfun);\n    let rowContent = MatrixVisualization.getRowContent(rowResult, matrix);\n\n    let columnResult = this.calculateColumnwise(columnlength, mfun);\n    let colContent = MatrixVisualization.getRowContent(columnResult, matrix);\n\n     let maxResult=  [...rowResult.map(el=>el[0]), ...columnResult.map(el=>el[0]), diagonal[0], antiDiagonal[0]].reduce((ac, el)=>ac<el?el:ac);\n    \n    \n    let maxContent =<Container textAlign=\"center\"> <Card>\n    <Image src='https://www.flaticon.com/svg/vstatic/svg/261/261992.svg?token=exp=1616746093~hmac=1da234452297d55dfca6fe21e1ccca32' wrapped ui={false} />\n    <Card.Content>\n      <Card.Header>Max of four</Card.Header>\n      <Card.Meta>\n        <span className='date'>diagonally, antiDiagonally, row-wise and columnwise...</span>\n      </Card.Meta>\n      <Card.Description>\n         {maxResult}\n      </Card.Description>\n    </Card.Content>\n    <Card.Content extra>\n        \n    </Card.Content>\n  </Card>\n  </Container>\n    this.state = {\n      data: matrix,\n      columnlength: columnlength,\n      activeItem: {},\n      diagonalContent: diagonalContent,\n      diagonalExplanation: diagonalExplanation,\n      antiDiagonalContent: antiDiagonalContent,\n      antiDiagonalExplanation: antiDiagonalExplanation,\n      rowContent: rowContent,\n      colContent: colContent,\n      columnResult: columnResult,\n      summaryContent: maxContent\n    };\n\n  }\n  /**\n   *  Method to initate the calculation\n   * Althought these methods are short enough to be inlined \n   * it is a central part of the logic so it makes \n   * sense to seperate them and it could be advantageous for test.\n   * @param {int} columnlength \n   * @param {MatrixFun} mfun \n   * @returns [int max, [...indexes]]\n   */\n    calculateDiagonal(columnlength, mfun) {\n    let diagonalMax = mfun.CalculateProductForRange(columnlength, (colInd, colLength) => mfun.getDiagonalIndex(colInd, colLength), 4);\n    return diagonalMax;\n\n  }\n\n  /**\n   * Method to initiate calculation of antidiagonal\n   * @param {int} columnlength \n   * @param {MatrixFun} mfun \n   * @returns [int max, [...indexes]]\n   */\n  calculateAntidiagonal(columnlength, mfun) {\n    let antiDiagonal = mfun.CalculateProductForRange(columnlength, (colInd, colLength) => mfun.getAntiDiagonalIndex(colInd, colLength), 4)\n    return antiDiagonal;\n  }\n  \n  //We are re-using the same calculation method. We only need to adjust the order of iteration.\n  calculateRows(squareLength, mfun) {\n    let rowIndex = mfun.getRowIndexes(squareLength, squareLength);\n    const rowResult = [];\n    [...new Array(squareLength)].forEach((_, offset) =>\n      rowResult.push(mfun.CalculateProductForRange(squareLength, (colInd, colLength) => (rowIndex[colInd] + offset), 4))\n    )\n    return rowResult;\n  }\n\n  calculateColumnwise(squareLength, mfun) {\n    const rowResult = [];\n    [...new Array(squareLength)].forEach((_, offset) =>\n      rowResult.push(mfun.CalculateProductForRange(squareLength, (colInd, colLength) => (colInd + (colLength*offset)), 4))\n    )\n    return rowResult;\n  }\n\n  //React lifecycle method. Ignore\n  componentDidMount() {\n    console.debug(\"this.menus\", this.menues);\n    this.menues.scrollIntoView();\n\n  }\n  //React lifecycle method. Ignore\n  componentDidUpdate() {\n    this.menues.scrollIntoView({ \"behavior\": \"smooth\", \"block\": \"start\" });\n  }\n  handleItemClick = (e, { name }) => {\n    this.setState({ activeItem: name })\n  }\n\n  render() {\n    let activeItem = this.state.activeItem;\n    let content = \"\";\n    let explanation = \"\";\n    switch (activeItem) {\n      case \"Diagonal\":\n        content = this.state.diagonalContent;\n        explanation = this.state.diagonalExplanation;\n        break;\n      case \"AntiDiagonal\":\n        content = this.state.antiDiagonalContent\n        explanation = this.state.antiDiagonalExplanation\n        break;\n      case \"Rows\":\n        content = this.state.rowContent;\n        break;\n      case \"Columnwise\":\n        content = this.state.colContent;\n        break;\n      case \"Summary\":\n        content = this.state.summaryContent;\n        break;\n      default: content=\"\";\n    }\n    return (\n      <div className=\"App\">\n\n        <div className=\"App-header\">\n          <h2>M A T R I X</h2>\n        </div>\n\n        <div className=\"App-body\">\n\n\n\n          <Grid columns={2} divided>\n            <Grid.Column>\n              {content}\n            </Grid.Column>\n\n            <Grid.Column>\n\n              {explanation}\n\n\n            </Grid.Column>\n          </Grid>\n          <div ref={el => this.menues = el}>\n            <Menu attached='bottom' tabular>\n              <Menu.Item\n                name='Diagonal'\n                active={activeItem === 'Diagonal'}\n                onClick={this.handleItemClick}\n\n              >\n                Diagonal\n                      </Menu.Item>\n\n              <Menu.Item\n                name='AntiDiagonal'\n                active={activeItem === 'AntiDiagonal'}\n                onClick={this.handleItemClick}\n              >\n                AntiDiagonal\n                      </Menu.Item>\n\n              <Menu.Item\n                name='Columnwise'\n                active={activeItem === 'Columnwise'}\n                onClick={this.handleItemClick}\n              >\n                Columnwise\n                      </Menu.Item>\n\n              <Menu.Item\n                name='Rows'\n                active={activeItem === 'Rows'}\n                onClick={this.handleItemClick}\n              >\n                Rows\n                      </Menu.Item>\n\n              <Menu.Item\n                name='Summary'\n                active={activeItem === 'Summary'}\n                onClick={this.handleItemClick}\n              >\n                Summary\n                      </Menu.Item>\n            </Menu>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals(console.log);\n"],"sourceRoot":""}