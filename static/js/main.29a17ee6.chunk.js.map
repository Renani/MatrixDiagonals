{"version":3,"sources":["main/MatrixFun.js","main/Matrixtable.js","main/MatrixVisualization.js","App.js","reportWebVitals.js","index.js"],"names":["MatrixFun","matrix","this","paddingValue","index","squareLength","undefined","console","error","col","row","Array","keys","map","element","getIndex","range","maxDiagonal","winners","forEach","_","ind","candidates","localMax","el","counter","adjacentIndex","cInd","push","reduce","acc","numbers","MatrixTable","createTable","thisState","local","toBeMarked","props","mark","toBeSpeciallyMarked","markSpecial","cData","data","select","node","append","selectAll","enter","d","i","j","k","set","text","attr","get","needle","color","findIndex","className","ref","viewBox","preserveAspectRatio","Component","MatrixVisualization","antiDiagonalResult","columnlength","mfun","createContentForAntidiagonal","antiDiagonalIndex","getAntiDiagonalIndex","antiDiagonalContent","activeItem","callStack","getcallStackForAntiDiagonal","Segment","textAlign","href","methodFinder","commons","getCommonMethods","commonMethod","diagonalResult","createContentForDiagonal","diagonalIndexes","getDiagonalIndex","diagonalContent","getcallStackForDiagonal","rowResult","getCallStackForRowCalculation","getCallStackForColumnCalculation","maxResult","Container","App","handleItemClick","e","name","setState","handleScrollUp","buttonDown","current","scrollIntoView","handleScrollDown","buttonUp","React","createRef","menues","lines","replace","split","str","Number","parseInt","length","flattened","flat","diagonal","calculateDiagonal","content","getDiagonalContent","diagonalExplanation","antiDiagonal","calculateAntidiagonal","getAntiDiagonalContent","antiDiagonalExplanation","calculateRows","rowContent","getMultipleResultsContent","rowExplanation","getRowExplanation","columnResult","calculateColumnwise","colContent","colExplanation","getColumnExplanation","ac","summaryContent","getSummaryContent","summaryExplanation","getSummaryExplanation","state","CalculateProductForRange","colInd","colLength","rowIndex","getRowIndexes","offset","explanation","upButton","Button","icon","onClick","downButton","Grid","columns","doubling","stackable","Column","Menu","attached","tabular","Item","active","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","log"],"mappings":"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","file":"static/js/main.29a17ee6.chunk.js","sourcesContent":["/**\r\n * Contains Matrix functionality for finding max product of adjacent values in rows, columns, diagonal and antidiagonal.\r\n */\r\nexport class MatrixFun {\r\n\r\n    constructor(matrix) {\r\n        this.matrix = matrix;\r\n\r\n        //Padding the matrix with 1 for out of bounds values -( Alternative value would be 0)\r\n        this.paddingValue = 1;\r\n\r\n        //Note: the functions toString only returns [native code] if you do NOT bind methods\r\n    }\r\n\r\n    /** \r\n     * Calculates the position of a diagional value \r\n     * for a column\r\n     * @param {int} currentIndex \r\n     * @param {int} squareLength \r\n     * @returns  returns index + (squareLength*index )\r\n     */\r\n    getDiagonalIndex(index, squareLength) {\r\n        if (index === undefined || squareLength === undefined) { console.error(\"Missing parameters:index, squarelength \", [index, squareLength]) }\r\n        return (index + squareLength * index);\r\n    }\r\n    /**\r\n     * Calculates the position of an antidiagonal\r\n     * value for a column index.\r\n     * @param {int} index \r\n     * @param {int} squareLength \r\n     * @returns \r\n     */\r\n    getAntiDiagonalIndex(index, squareLength) {\r\n        if (index === undefined || squareLength === undefined) { console.error(\"Missing parameters:index, squarelength \", [index, squareLength]) }\r\n        return ((squareLength - index - 1) + squareLength * index);\r\n    }\r\n    /**\r\n     * Creates row-wise indexes.\r\n     * \r\n     * Parameters\r\n     *   col = Squarelength\r\n     *   row = squareLength\r\n     * \r\n     * @param {int} col \r\n     * @param {int} row \r\n     * @returns int [] of indexes in the first row\r\n     */\r\n    getRowIndexes(col, row) {\r\n        return [...Array(col).keys()].map(element => element * row);\r\n\r\n    }\r\n    /**\r\n     * This method does the actual calcuation of product between \"range\" values.\r\n     * The function passed as a parameter provides the index of values to be used,\r\n     * and is called 0...squarelength-1 times, with the counter as parameter. if the \r\n     * counter is increased beyond squarelength this method return the padding value,\r\n     * i.e. increasing the dimension of the matrix. The padding value is hard-coded to\r\n     * 1. \r\n     * @param {int} squareLength \r\n     * @param {func(currentIndex, squareLength) return index of value} getIndex \r\n     * @param {int} range \r\n     * @returns [int max, [...indexes]]\r\n     */\r\n    CalculateProductForRange(squareLength, getIndex, range) {\r\n        let maxDiagonal = 0;\r\n        let winners = [];\r\n\r\n        //Stream of indexes vs for-loop?\r\n        [...new Array(squareLength)].forEach((_, ind) => {\r\n\r\n            let candidates = [];\r\n            let localMax = [...new Array(range)].map((el, counter) => {\r\n                let adjacentIndex = ind + counter;\r\n\r\n                //Padding the matrix with 1 (0 is another alternative if you want to discard the last (range-1) values)\r\n                if (adjacentIndex >= squareLength) { return this.paddingValue }\r\n\r\n                let cInd = getIndex(adjacentIndex, squareLength);\r\n                candidates.push(cInd);\r\n                return this.matrix[cInd];\r\n            }\r\n            )\r\n                .reduce((acc, el) => acc * el);\r\n\r\n            if (localMax > maxDiagonal) {\r\n                maxDiagonal = localMax;\r\n                winners = candidates;\r\n            }\r\n        });\r\n\r\n        return [maxDiagonal, winners];\r\n    }\r\n\r\n    /**\r\n     * Multiplication of array of numbers.\r\n     * @param {Number} numbers \r\n     * @returns \r\n     */\r\n    calculateProduct(numbers) {\r\n        return numbers.reduce((acc, element) => acc * element);\r\n    }\r\n\r\n}\r\n\r\n","\r\nimport React, { Component } from 'react';\r\n\r\n\r\nimport { select, local } from 'd3-selection';\r\n\r\nclass MatrixTable extends Component {\r\n \r\n    componentDidMount() {\r\n\r\n        this.createTable();\r\n\r\n    }\r\n    componentDidUpdate() {\r\n        this.createTable();\r\n    }\r\n\r\n\r\n    createTable() {\r\n        let thisState = local();\r\n        let toBeMarked = this.props.mark;\r\n        let toBeSpeciallyMarked = this.props.markSpecial;\r\n        let cData = this.props.data;\r\n\r\n        let svg = select(this.node);\r\n        svg.append(\"g\")\r\n            .selectAll(\"g\")\r\n            .data(cData)\r\n            .enter()\r\n            .append(\"g\") //removing\r\n            .selectAll(\"text\") // these\r\n            .data(function (d, i, j, k) { thisState.set(this, i); return d }) //lines\r\n            .enter() //text displays normally\r\n            .append(\"text\")\r\n            .text(function (d, i, j) { return d; })\r\n            .attr(\"x\", function (d, i) { return (i * 40) + 20; })\r\n            .attr(\"y\", function (d, i) { return (thisState.get(this) * 40) + 90; })\r\n\r\n            .attr(\"font-family\", \"Helvetica\")\r\n            .attr(\"font-size\", \"20px\")\r\n            .attr(\"fill\", function (d, i) {\r\n                let needle = thisState.get(this) * 20 + i;\r\n                let color = \"black\"\r\n                if (toBeMarked) {\r\n\r\n                    if (toBeMarked.findIndex((el) => el === needle) !== -1) {\r\n                        color = \"Orange\";\r\n                    } else\r\n                        color = \"green\";\r\n                }\r\n\r\n                if (toBeSpeciallyMarked) {\r\n                    if (toBeSpeciallyMarked.findIndex((el) => el === needle) !== -1) {\r\n                        color = \"Red\";\r\n                    }\r\n                }\r\n\r\n                return color;\r\n\r\n            })\r\n    }\r\n\r\n\r\n    render() {\r\n\r\n        return ( <div className=\"svg-container\">\r\n                   <svg ref={node => this.node = node} viewBox=\"0 0 1000 1000\" preserveAspectRatio=\"xMidYMid meet\" className=\"svg-content\">\r\n                 </svg>\r\n                </div >\r\n        )\r\n    }\r\n\r\n}\r\n\r\nexport default MatrixTable;","/**\r\n *  Creates visualization components\r\n * \r\n */\r\nimport React, { Component } from 'react';\r\nimport MatrixTable from './Matrixtable'\r\nimport {\r\n    Segment,\r\n    Card,\r\n    Image,\r\n    Container\r\n\r\n} from 'semantic-ui-react';\r\n\r\n\r\n\r\n\r\nclass MatrixVisualization extends Component {\r\n    static getAntiDiagonalContent(antiDiagonalResult, columnlength, matrix, mfun, createContentForAntidiagonal) {\r\n\r\n\r\n        const antiDiagonalIndex = [...new Array(20)].map((el, ind) => { return mfun.getAntiDiagonalIndex(ind, columnlength) });\r\n        const antiDiagonalContent = <div><h3> Product:{antiDiagonalResult[0]}</h3><MatrixTable data={matrix} mark={antiDiagonalIndex} markSpecial={antiDiagonalResult[1]} key={this.activeItem}></MatrixTable></div>;\r\n        const callStack = this.getcallStackForAntiDiagonal();\r\n\r\n        const antiDiagonalExplanation = <Segment textAlign=\"left\">\r\n            <Segment>Alternative would be transposing the matrix</Segment>\r\n                     Initiating calculation from <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/App.js\" >App.js</a> with diagional index finder method.\r\n                                <pre>{callStack[0]}</pre>\r\n                                antidiagonal index finder method defined in <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>;\r\n                                <pre>{callStack[1]}</pre>\r\n                                This calculation method calls indexfinder and finds it's adjacent values defined in<a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.\r\n                                This method is used for all types of iterations:\r\n                                <pre>{callStack[2]}</pre>\r\n                                Seperated the actual Multiplication in a seperate method. I can imagine a situation where there will be need to change this operation. Defined in<a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.\r\n                                <pre>{callStack[3]}</pre>\r\n        </Segment>\r\n        return [antiDiagonalContent, antiDiagonalExplanation]\r\n    }\r\n\r\n    static getCallStackForColumnCalculation() {\r\n        const methodInitiate =\r\n            `\r\ncalculateColumnwise(squareLength, mfun) {\r\n    const rowResult = [];\r\n    [...new Array(squareLength)].forEach((_, offset) =>\r\n      rowResult.push(mfun.CalculateProductForRange(squareLength,\r\n        (colInd, colLength) => (colInd + (colLength*offset)), 4))\r\n    )\r\n    return rowResult;\r\n  }\r\n`;\r\n        const methodFinder = undefined;\r\n\r\n        const commons = this.getCommonMethods();\r\n        return [methodInitiate, methodFinder, ...commons];\r\n    }\r\n\r\n    static getCallStackForRowCalculation() {\r\n        const methodInitiate = `\r\n//We are re-using the same product calculation method. We only need to adjust the order of iteration.\r\ncalculateRows(squareLength, mfun) {\r\n    let rowIndex = mfun.getRowIndexes(squareLength, squareLength);\r\n    const rowResult = [];\r\n    [...new Array(squareLength)].forEach((_, offset) =>\r\n    rowResult.push(mfun.CalculateProductForRange(squareLength, \r\n        (colInd, colLength) => (rowIndex[colInd] + offset), 4))\r\n    )\r\n    return rowResult;\r\n} \r\n`;\r\n\r\n        const methodFinder = `\r\n/**\r\n * Creates row-wise indexes.\r\n * Parameters\r\n *   col = Squarelength\r\n *   row = squareLength\r\n * @param {int} col \r\n * @param {int} row \r\n * @returns int [] of indexes in the first row\r\n */\r\ngetRowIndexes(col, row) {\r\n    return [...Array(col).keys()].map(element => element * row);\r\n\r\n}\r\n `;\r\n        let commons = this.getCommonMethods();\r\n        return [methodInitiate, methodFinder, ...commons];\r\n    }\r\n\r\n    static getcallStackForAntiDiagonal() {\r\n        const methodInitiate = `\r\n/**\r\n * Method to initiate calculation of antidiagonal\r\n * @param {int} columnlength \r\n * @param {MatrixFun} mfun \r\n * @returns [int max, [...indexes]]\r\n */\r\ncalculateAntidiagonal(columnlength, mfun) {\r\n    let antiDiagonal = mfun.CalculateProductForRange(columnlength, \r\n        (colInd, colLength) => mfun.getAntiDiagonalIndex(colInd, colLength), 4)\r\n    return antiDiagonal;\r\n}\r\n        `;\r\n\r\n        const methodIndexfinder = `\r\n/**\r\n* Calculates the position of an antidiagonal\r\n* value for a column index.\r\n* @param {int} index \r\n* @param {int} squareLength \r\n* @returns \r\n*/\r\ngetAntiDiagonalIndex(index, squareLength) {\r\n    if (index === undefined || squareLength === undefined) { \r\n        console.error(\"Missing parameters:index, squarelength \", [index, squareLength])\r\n    }\r\n    return ((squareLength - index - 1) + squareLength * index);\r\n}\r\n    `;\r\n        let commons = this.getCommonMethods();\r\n        return [methodInitiate, methodIndexfinder, ...commons];\r\n    }\r\n\r\n    static getcallStackForDiagonal() {\r\n        const methodInitiate = `\r\n/**\r\n*  Method to initate the calculation\r\n* Althought these methods are short enough to be inlined \r\n* it is a central part of the logic so it makes \r\n* sense to seperate them and it could be advantageous for test.\r\n* @param {*} columnlength \r\n* @param {*} mfun \r\n* @returns [int max, [...indexes]]\r\n*/\r\ncalculateDiagonal(columnlength, mfun) {\r\n        let diagonalMax = mfun.CalculateProductForRange(\r\n        columnlength, \r\n        (colInd, colLength) =>\r\n         mfun.getDiagonalIndex(colInd, colLength), \r\n         4);\r\n    return diagonalMax;\r\n}`;\r\n\r\n        const methodIndexfinder = `\r\n/** \r\n * Calculates the position of a diagional value \r\n * for a column\r\n * @param {int} currentIndex \r\n * @param {int} squareLength \r\n * @returns  returns index + (squareLength*index )\r\n */\r\ngetDiagonalIndex(index, squareLength) {\r\n    if (index === undefined || squareLength === undefined) { \r\n        console.error(\"Missing parameters:index, squarelength \", \r\n            [index, squareLength]) \r\n    }\r\n    return (index + squareLength * index);\r\n}\r\n`;\r\n        const commonMethod = this.getCommonMethods();\r\n        return [methodInitiate, methodIndexfinder, ...commonMethod]\r\n    }\r\n    static getCommonMethods() {\r\n        const methodCalculator =\r\n            `\r\n/**\r\n * This method does the actual calcuation of \r\n * product between \"range\" values.\r\n * The function passed as a parameter provides \r\n * the index of values to be used,\r\n * and is called 0...squarelength-1 times, \r\n * with the counter as parameter. if the \r\n * counter is increased beyond squarelength \r\n * this method return the padding value,\r\n * i.e. increasing the dimension of the matrix.\r\n * The padding value is hard-coded to 1. \r\n * @param {int} squareLength \r\n * @param {func(currentIndex, squareLength) return index of value} getIndex \r\n * @param {int} range \r\n * @returns [int max, [...indexes]]\r\n */\r\nCalculateProductForRange(squareLength, getIndex, range) {\r\nlet maxDiagonal = 0;\r\nlet winners = [];\r\n\r\n//Stream of indexes vs for-loop?\r\n[...new Array(squareLength)].forEach((_, ind) => {\r\n\r\n    let candidates = [];\r\n    let localMax = [...new Array(range)].map((el, counter) => \r\n    {\r\n        let adjacentIndex = ind + counter;\r\n\r\n//Padding the matrix with 1 (0 is another \r\n//alternative if you want to discard the last (range-1) values)\r\n        if (adjacentIndex >= squareLength) { \r\n            return this.paddingValue \r\n        }\r\n\r\n        let cInd = getIndex(adjacentIndex, squareLength);\r\n        candidates.push(cInd);\r\n        return this.matrix[cInd];\r\n    })\r\n    .reduce((acc, el) => acc * el);\r\n\r\n    if (localMax > maxDiagonal) {\r\n        maxDiagonal = localMax;\r\n        winners = candidates;\r\n    }\r\n});\r\n\r\nreturn [maxDiagonal, winners];\r\n}\r\n`;\r\n\r\n        const methodMulti =\r\n            `\r\n/**\r\n * Multiplication of array of numbers.\r\n * @param {Number} numbers \r\n * @returns \r\n */\r\ncalculateProduct(numbers) {\r\nreturn numbers.reduce((acc, element) => acc * element);\r\n}`\r\n\r\n\r\n        return [methodCalculator, methodMulti];\r\n\r\n    }\r\n\r\n    static getDiagonalContent(diagonalResult, columnlength, matrix, mfun, createContentForDiagonal) {\r\n        //Creating view information for diagonals    \r\n        const diagonalIndexes = [...new Array(20)].map((el, ind) => { return mfun.getDiagonalIndex(ind, columnlength) });\r\n        const diagonalContent = <div><h3> Product:{diagonalResult[0]}</h3> <MatrixTable data={matrix} mark={diagonalIndexes} markSpecial={diagonalResult[1]} key={this.activeItem}></MatrixTable></div>;\r\n        const callStack = this.getcallStackForDiagonal();\r\n\r\n\r\n        const diagonalExplanation = <Segment textAlign=\"left\">\r\n            <Segment>In Matlab it would have simply been creating identity matrix with equal dimensions and multiply</Segment>\r\n                                Initiating calculation from <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/App.js\" >App.js</a> with diagional index finder method.\r\n                                <pre>{callStack[0]}</pre>\r\n                                The Diagonal index finder method defined in <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>;\r\n                                <pre>{callStack[1]}</pre>\r\n                                This calculation method calls indexfinder and finds it's adjacent values defined in<a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.\r\n                                This method is used for all types of iteration:\r\n                                <pre>{callStack[2]}</pre>\r\n                                Seperated the actual Multiplication in a seperate method. I can imagine a situation where there will be need to change this operation. Defined in<a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.\r\n                                <pre>{callStack[3]}</pre>\r\n\r\n        </Segment>\r\n        return [diagonalContent, diagonalExplanation]\r\n    }\r\n\r\n    static getMultipleResultsContent(rowResult, matrix) {\r\n        return rowResult.map((el, ind) => <div><h3>Number {ind}. Product:{el[0]}</h3><MatrixTable key={ind} data={matrix} markSpecial={el[1]} ></MatrixTable></div>);\r\n    }\r\n    static getRowExplanation() {\r\n        const callStack = this.getCallStackForRowCalculation();\r\n        const explanation =\r\n            <Segment textAlign=\"left\">\r\n                We are calling the same method for diagionals, but now we have 20 more sets to iterate.\r\n            <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/App.js\" >App.js</a>.\r\n            <pre>{callStack[0]}</pre>\r\n                <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>\r\n            we have a method to create array of the first indexes. To get index of a row for a column we just have to add the column offset.\r\n            <pre>{callStack[1]}</pre>\r\n            This calculation method calls indexfinder and finds it's adjacent values defined in\r\n            <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.This method is used for all types of iteration:\r\n            <pre>{callStack[2]}</pre>\r\n            Seperated the actual Multiplication in a seperate method.\r\n            I can imagine a situation where there will be need to change this operation.\r\n            Defined in<a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.\r\n            <pre>{callStack[3]}</pre>\r\n            </Segment>\r\n        return explanation;\r\n    }\r\n\r\n    static getColumnExplanation() {\r\n        const callStack = this.getCallStackForColumnCalculation();\r\n        const explanation =\r\n            <Segment textAlign=\"left\">\r\n                Simple iteration like we did for rows, but much simpler now that values are in rows. No need for a separate index finder method here; we can define it directly in this method.\r\n            <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/App.js\" >App.js</a>.\r\n            <pre>{callStack[0]}</pre>\r\n            This calculation method calls indexfinder and finds it's adjacent values defined in\r\n            <a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.This method is used for all types of iteration:\r\n            <pre>{callStack[2]}</pre>\r\n            Seperated the actual Multiplication in a seperate method.\r\n            I can imagine a situation where there will be need to change this operation.\r\n            Defined in<a href=\"https://github.com/Renani/MatrixDiagonals/blob/master/src/main/MatrixFun.js\"> MatrixFun.js</a>.\r\n            <pre>{callStack[3]}</pre>\r\n            </Segment>\r\n        return explanation;\r\n    }\r\n\r\n    static getSummaryContent(maxResult) {\r\n\r\n        let maxContent = <Container textAlign=\"center\">\r\n            {maxResult}\r\n        </Container>\r\n\r\n        return maxContent;\r\n    }\r\n\r\n    static getSummaryExplanation() {\r\n        let calculation = \"[...rowResult.map(el => el[0]), ...columnResult.map(el => el[0]), diagonal[0], antiDiagonal[0]].reduce((ac, el) => ac < el ? el : ac);\";\r\n        let expl = <Container textAlign=\"left\">\r\n            <p>In this document we have looked into one way iterate through a matrix along all the straight lines to find 4 numbers, which when multiplied produces the greates value.\r\n            The iteration methods have been based on modern Javascript language and the goal was to create it as smallest and readable as possible,\r\n            and at the same time transferable to other languages. I should mention that there were times where I missed the \"colon\" operator of Matlab (which has later been copied by Python).\r\n                  </p>\r\n            <p>\r\n                For the visualization I have used React, Semantic and D3JS.\r\n                These framework provides easy mean of interaction and D3Js provides means of visualization. Mike Bostock has done great work at showcasing the capabilities of D3Js and I do love the make data more beautiful initiavies.\r\n                  </p>\r\n            <p>\r\n                I should mention that for more advanced project I prefer to use the Java language. I feel that with languages that do not have Objects and strict types there are always potential chances to create informal and undocumented structures\r\n                that will steal your time. Of course a great argument for using Java is the great support for integration into enterprise infrastructure. However, I cannot deny the simplicity of the latest syntax in more functional languages when it comes to processing data(although Javascript is neither functional or Object-oriented).\r\n                This has been a small project to look into what Javascript can offer, and also learn more about React and D3js.\r\n                  </p>\r\n            <p>\r\n                My Github contains other projects where I have looked into other aspects, and I plan to add a small Kotlin project soon.\r\n            </p>\r\n                The final result is calculated by combining results from all the straight lines, map and then reduce using a compare function.\r\n                <pre>{calculation}</pre>\r\n        </Container>\r\n        return expl;\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default MatrixVisualization\r\n","\nimport './App.css';\nimport 'semantic-ui-css/semantic.min.css'\nimport React from 'react';\nimport { MatrixFun } from './main/MatrixFun.js'\n\nimport MatrixVisualization from './main/MatrixVisualization'\nimport {\n  Grid,\n  Menu,\n  \n  Button\n  \n} from 'semantic-ui-react';\nclass App extends React.Component {\n\n  constructor(props) {\n    super(props)\n    this.buttonUp=React.createRef();\n    this.buttonDown = React.createRef();\n    this.menues = React.createRef();\n\n    let text = \"08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\\n\" +\n      \"49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\\n\" +\n      \"81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\\n\" +\n      \"52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\\n\" +\n      \"22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\\n\" +\n      \"24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\\n\" +\n      \"32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\\n\" +\n      \"67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\\n\" +\n      \"24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\\n\" +\n      \"21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\\n\" +\n      \"78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\\n\" +\n      \"16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\\n\" +\n      \"86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\\n\" +\n      \"19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\\n\" +\n      \"04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\\n\" +\n      \"88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\\n\" +\n      \"04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\\n\" +\n      \"20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\\n\" +\n      \"20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\\n\" +\n      \"01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\";\n\n    let lines = text.replace('\"', \"\").split(\"\\n\");\n\n    const matrix = [];\n    lines.forEach((element, index) => { matrix[index] = element.split(\" \").map(str => Number.parseInt(str)) });\n\n    const columnlength = matrix[0].length;\n\n    const flattened = matrix.flat();\n\n    const mfun = new MatrixFun(flattened);\n    //Calculating diagional\n    let diagonal = this.calculateDiagonal(columnlength, mfun);\n    //creating view for Diagonal\n    let content = MatrixVisualization.getDiagonalContent(diagonal, columnlength, matrix, mfun, this.calculateDiagonal);\n    const diagonalContent = content[0];\n    const diagonalExplanation = content[1];\n\n    //Calculating antidiagonal\n    const antiDiagonal = this.calculateAntidiagonal(columnlength, mfun);\n    //Creating view for antidiagonals\n    content = MatrixVisualization.getAntiDiagonalContent(antiDiagonal, columnlength, matrix, mfun, this.calculateAntidiagonal);\n    const antiDiagonalContent = content[0];\n    const antiDiagonalExplanation = content[1];\n\n    let rowResult = this.calculateRows(columnlength, mfun);\n    let rowContent = MatrixVisualization.getMultipleResultsContent(rowResult, matrix);\n    let rowExplanation = MatrixVisualization.getRowExplanation();\n\n    let columnResult = this.calculateColumnwise(columnlength, mfun);\n    let colContent = MatrixVisualization.getMultipleResultsContent(columnResult, matrix);\n    let colExplanation = MatrixVisualization.getColumnExplanation();\n\n\n    let maxResult = [...rowResult.map(el => el[0]), ...columnResult.map(el => el[0]), diagonal[0], antiDiagonal[0]].reduce((ac, el) => ac < el ? el : ac);\n    const summaryContent = MatrixVisualization.getSummaryContent (maxResult)\n    const summaryExplanation = MatrixVisualization.getSummaryExplanation();\n\n    this.state = {\n      data: matrix,\n      columnlength: columnlength,\n      activeItem: {},\n      diagonalContent: diagonalContent,\n      diagonalExplanation: diagonalExplanation,\n      antiDiagonalContent: antiDiagonalContent,\n      antiDiagonalExplanation: antiDiagonalExplanation,\n      rowContent: rowContent,\n      rowExplanation: rowExplanation,\n      colContent: colContent,\n      colExplanation: colExplanation,\n      summaryContent: summaryContent,\n      summaryExplanation: summaryExplanation\n\n    };\n\n  }\n  /**\n   *  Method to initate the calculation\n   * Althought these methods are short enough to be inlined \n   * it is a central part of the logic so it makes \n   * sense to seperate them and it could be advantageous for test.\n   * @param {int} columnlength \n   * @param {MatrixFun} mfun \n   * @returns [int max, [...indexes]]\n   */\n  calculateDiagonal(columnlength, mfun) {\n    let diagonalMax = mfun.CalculateProductForRange(columnlength, (colInd, colLength) => mfun.getDiagonalIndex(colInd, colLength), 4);\n    return diagonalMax;\n\n  }\n\n  /**\n   * Method to initiate calculation of antidiagonal\n   * @param {int} columnlength \n   * @param {MatrixFun} mfun \n   * @returns [int max, [...indexes]]\n   */\n  calculateAntidiagonal(columnlength, mfun) {\n    let antiDiagonal = mfun.CalculateProductForRange(columnlength, (colInd, colLength) => mfun.getAntiDiagonalIndex(colInd, colLength), 4)\n    return antiDiagonal;\n  }\n\n  //We are re-using the same product calculation method. We only need to adjust the order of iteration.\n  calculateRows(squareLength, mfun) {\n    let rowIndex = mfun.getRowIndexes(squareLength, squareLength);\n    const rowResult = [];\n    [...new Array(squareLength)].forEach((_, offset) =>\n      rowResult.push(mfun.CalculateProductForRange(squareLength, (colInd, colLength) => (rowIndex[colInd] + offset), 4))\n    )\n    return rowResult;\n  }\n\n  calculateColumnwise(squareLength, mfun) {\n    const rowResult = [];\n    [...new Array(squareLength)].forEach((_, offset) =>\n      rowResult.push(mfun.CalculateProductForRange(squareLength, (colInd, colLength) => (colInd + (colLength * offset)), 4))\n    )\n    return rowResult;\n  }\n\n  //React lifecycle method. Ignore\n  componentDidMount() {\n   this.menues.current.scrollIntoView({ \"behavior\": \"smooth\", \"block\": \"start\" });\n  }\n  //React lifecycle method. Ignore\n  componentDidUpdate() {\n     this.buttonDown.current.scrollIntoView({ \"behavior\": \"smooth\", \"block\": \"start\" });;\n  }\n  \n\n  handleItemClick = (e, { name }) => {\n    this.setState({ activeItem: name })\n  }\n  handleScrollUp = (e, { name }) => {\n    this.buttonDown.current.scrollIntoView({ \"behavior\": \"smooth\", \"block\": \"start\" });;\n  }\n\n  handleScrollDown = (e, { name }) => {\n    this.buttonUp.current.scrollIntoView({ \"behavior\": \"smooth\", \"block\": \"start\" });;\n  }\n\n  render() {\n    let activeItem = this.state.activeItem;\n    let content = \"\";\n    let explanation = \"\";\n    switch (activeItem) {\n      case \"Diagonal\":\n        content = this.state.diagonalContent;\n        explanation = this.state.diagonalExplanation;\n        break;\n      case \"AntiDiagonal\":\n        content = this.state.antiDiagonalContent\n        explanation = this.state.antiDiagonalExplanation\n        break;\n      case \"Rows\":\n        content = this.state.rowContent;\n        explanation = this.state.rowExplanation;\n        break;\n      case \"Columnwise\":\n        content = this.state.colContent;\n        explanation = this.state.colExplanation;\n        break;\n      case \"Summary\":\n        content = this.state.summaryContent;\n        explanation = this.state.summaryExplanation;\n        break;\n      default: ;\n    }\n    const upButton =<div ref={this.buttonUp}> <Button icon=\"angle double up\"  onClick={this.handleScrollUp}  ></Button></div>\n    const downButton =<div ref={this.buttonDown}> <Button icon=\"angle double down\"  onClick={this.handleScrollDown} ></Button></div>\n    return (\n      <div className=\"App\">\n\n        <div className=\"App-header\">\n          <h2>M A T R I X</h2>\n        </div>\n\n        <div className=\"App-body\">\n\n          {content ? downButton : \"\"}\n\n          <Grid columns={2} doubling stackable>\n            <Grid.Column>\n\n              {content}\n\n            </Grid.Column>\n\n            <Grid.Column >\n\n              {explanation}\n\n            </Grid.Column>\n\n          </Grid>\n\n          <div ref={this.menues}>\n            {content ? upButton : \"\"}\n            <Menu attached='bottom' tabular>\n              <Menu.Item\n                name='Diagonal'\n                active={activeItem === 'Diagonal'}\n                onClick={this.handleItemClick}\n\n              >\n                Diagonal\n                      </Menu.Item>\n\n              <Menu.Item\n                name='AntiDiagonal'\n                active={activeItem === 'AntiDiagonal'}\n                onClick={this.handleItemClick}\n              >\n                AntiDiagonal\n                      </Menu.Item>\n\n              <Menu.Item\n                name='Columnwise'\n                active={activeItem === 'Columnwise'}\n                onClick={this.handleItemClick}\n              >\n                Columnwise\n                      </Menu.Item>\n\n              <Menu.Item\n                name='Rows'\n                active={activeItem === 'Rows'}\n                onClick={this.handleItemClick}\n              >\n                Rows\n                      </Menu.Item>\n\n              <Menu.Item\n                name='Summary'\n                active={activeItem === 'Summary'}\n                onClick={this.handleItemClick}\n              >\n                Summary\n                      </Menu.Item>\n            </Menu>\n          </div>\n\n\n\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals(console.log);\n"],"sourceRoot":""}